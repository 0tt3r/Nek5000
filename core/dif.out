conduct.f bckup0
16c16
< 
---
> C
131c131
<       time = time-dt        ! Set time to t^n-1 for user function
---
>       if (.not.ifcvfld(ifield)) time = time-dt ! Set time to t^n-1 for user function
132a133
>       call rzero   (bq(1,1,1,1,ifield-1),n)
134,135d134
<       if (ifcvfld(ifield)) call copy (tlag(1,1,1,1,1,ifield-1),
<      &                                bq  (1,1,1,1,ifield-1),n)
138c137
<       time = time+dt        ! Restore time
---
>       if (.not.ifcvfld(ifield)) time = time+dt ! Restore time
204c203
<          call nekasgn (i,j,k,iel)
---
>          if (optlevel.le.2) call nekasgn (i,j,k,iel)
224,226c223,225
< 
<       common /scruz/ ta (lx1*ly1*lz1*lelt)
< 
---
> C
>       COMMON /SCRUZ/ TA (LX1,LY1,LZ1,LELT)
> C
229d227
< 
231,235c229,231
<       do i=1,n
<         bq(i,1,1,1,ifield-1) = bq (i,1,1,1,ifield-1)
<      $                       - bm1(i,1,1,1)*ta(i)*vtrans(i,1,1,1,ifield)
<       enddo
< 
---
>       CALL COL2    (TA,VTRANS(1,1,1,1,IFIELD),N)
>       CALL SUBCOL3 (BQ(1,1,1,1,IFIELD-1),BM1,TA,N)
> C
246c242,244
< 
---
> C
>       COMMON /SCRUZ/ TA (LX1,LY1,LZ1,LELT)
> C
251,259c249,258
<       n     = lx1*ly1*lz1*nel
< 
<       do i=1,n
<          ta=ab1*vgradt1(i,1,1,1,ifield-1)+ab2*vgradt2(i,1,1,1,ifield-1)
<          vgradt2(i,1,1,1,ifield-1)=vgradt1(i,1,1,1,ifield-1)
<          vgradt1(i,1,1,1,ifield-1)=bq     (i,1,1,1,ifield-1)
<          bq     (i,1,1,1,ifield-1)=bq     (i,1,1,1,ifield-1)*ab0+ta
<       enddo
< 
---
>       N = NX1*NY1*NZ1*NEL
> C
>       CALL ADD3S2 (TA,VGRADT1(1,1,1,1,IFIELD-1),
>      $                VGRADT2(1,1,1,1,IFIELD-1),AB1,AB2,N)
>       CALL COPY   (   VGRADT2(1,1,1,1,IFIELD-1),
>      $                VGRADT1(1,1,1,1,IFIELD-1),N)
>       CALL COPY   (   VGRADT1(1,1,1,1,IFIELD-1),
>      $                     BQ(1,1,1,1,IFIELD-1),N)
>       CALL ADD2S1 (BQ(1,1,1,1,IFIELD-1),TA,AB0,N)
> C
263c262
<       subroutine makebdq1
---
>       subroutine makebdq
279a279
> c      call cmult2(h2,vtrans(1,1,1,1,ifield),const,n)
296,311d295
<       call addcol3 (bq(1,1,1,1,ifield-1),tb,h2,n)
< 
<       return
<       end
< c-----------------------------------------------------------------------
<       subroutine makebdq
< C-----------------------------------------------------------------------
< C
< C     Add contributions to F from lagged BD terms.
< C
< C-----------------------------------------------------------------------
<       include 'SIZE'
<       include 'TOTAL'
< 
<       parameter (lt=lx1*ly1*lz1*lelt)
< 
313,343c297,300
<       nel   = nelfld(ifield)
<       n     = nx1*ny1*nz1*nel
<    
<       const = 1./dt
< 
<       if (nbd.eq.2) then
<        if (ifgeom) then
<         write(6,*) istep,' makebdq AAA'
<         do i=1,n
<          h2=const*vtrans(i,1,1,1,ifield)
<          tb=bd(2)*bm1(i,1,1,1)*t(i,1,1,1,ifield-1)
<          ta=bm1lag(i,1,1,1,1)*tlag(i,1,1,1,1,ifield-1)
<          bq(i,1,1,1,ifield-1)=bq(i,1,1,1,ifield-1)+h2*(tb+ta*bd(3))
<         enddo
<        else
<         write(6,*) istep,' makebdq BAA'
<         do i=1,n
<          h2=const*vtrans(i,1,1,1,ifield)
<          tb=bd(2)*bm1(i,1,1,1)*t(i,1,1,1,ifield-1)
<          ta=bm1(i,1,1,1)*tlag(i,1,1,1,1,ifield-1)
<          bq(i,1,1,1,ifield-1)=bq(i,1,1,1,ifield-1)+h2*(tb+ta*bd(3))
<         enddo
<        endif
<       else
<         write(6,*) istep,' makebdq CAA'
<         call makebdq1
<       endif
<       tl0=t   (1,1,1,1,1)
<       tl1=tlag(1,1,1,1,1,1)
<       write(6,1) istep,h2,tb,ta,bq(1,1,1,1,1),tl0,tl1
<     1 format(i4,'tabq: ',1p6e12.4)
---
> c      do i=1,n
> c         bq(i,1,1,1,ifield-1) = bq(i,1,1,1,ifield-1) + tb(i)*h2(i)
> c      enddo
>       call addcol3 (bq(1,1,1,1,ifield-1),tb,h2,n)
526,646d482
<       subroutine set_eta_alpha2
< 
< c     Set up required dg terms, e.g., alpha, eta, etc.
< c     Face weight: .5 interior, 1. boundary
< 
<       include 'SIZE'
<       include 'TOTAL'
<       common /mysedg/ eta
< 
< 
<       integer e,f,pf
< 
<       nface = 2*ndim
<       call dsset(nx1,ny1,nz1)
< 
<       eta =  5         !   Semi-optimized value, single domain
< 
<       do e=1,nelfld(ifield)
<       do f=1,nface
< 
<          pf     = eface1(f)
<          js1    = skpdat(1,pf)
<          jf1    = skpdat(2,pf)
<          jskip1 = skpdat(3,pf)
<          js2    = skpdat(4,pf)
<          jf2    = skpdat(5,pf)
<          jskip2 = skpdat(6,pf)
< 
<          i = 0
<          do j2=js2,jf2,jskip2
<          do j1=js1,jf1,jskip1
<             i = i+1
<             a = area(i,1,f,e)  ! Check Fydkowski notes 
<             a = a*a*fw(f,e)    ! For ds_avg used below, plus quad weight
<             etalph(i,f,e) = eta*(a/bm1(j1,j2,1,e))
< c           write(6,*) i,j1,j2,e,f,a,etalph(i,f,e)
<          enddo
<          enddo
<       enddo
<       enddo
< 
<       call gs_op (dg_hndlx,etalph,1,1,0)  ! 1 ==> +
< 
<       return
<       end
< c-----------------------------------------------------------------------
<       subroutine fwght(msk1,mult)
<       include 'SIZE'
<       include 'TOTAL'
<       parameter (lx=lx1*ly1*lz1)
<       real msk1(lx1,ly1,lz1),mult(lx1,ly1,lz1,1)
<       integer e,f,pf
< 
<       parameter(lf=lx1*lz1*2*ldim*lelt)
<       common /scrdg/uf(lx1*lz1,2*ldim,lelt)
< 
< 
< 
<       do i=1,lf
<          uf(i,1,1)=1.
<       enddo
<       call gs_op (dg_hndlx,uf,1,1,0)  ! 1 ==> +
< 
<       nface = 2*ldim
<       do e=1,nelt
<       do f=1,nface
<          fw(f,e) = 1                        ! Boundary
<          if (uf(1,f,e).gt.1.1) fw(f,e)=0.5  ! Interior
<       enddo
<       enddo
< 
<       return
<       end
< c-----------------------------------------------------------------------
<       subroutine dg_setup
<       include 'SIZE'
<       include 'TOTAL'
< 
<       common /ivrtx/ vertex ((2**ldim)*lelt)
<       common /ctmp1/ qs(lx1*ly1*lz1*lelt)
<       integer vertex
< 
<       if (ifdg) then
< 
<         call setup_dg_gs(dg_hndlx,nx1,ny1,nz1,nelt,nelgt,vertex)
<         call dg_set_fc_ptr
< 
<         param(59)=1
<         call geom_reset(1)
<         call set_unr
<       endif
< 
< 
<       n = nx1*ny1*nz1*nelt
<       call invers2(binvdg,bm1,n)
< 
<       call set_dg_wgts
< 
<       return
<       end
< c-----------------------------------------------------------------------
<       subroutine dg_setup2(mask)
<       include 'SIZE'
<       include 'TOTAL'
< 
<       real mask(1)
<       common /ctmp0/ qs(lx1*ly1*lz1*lelt)
< 
<       integer ifld_last
<       save    ifld_last
<       data    ifld_last /0/
< 
<       if (ifield.eq.ifld_last) return
<       ifld_last = ifield
< 
<       call fwght  (qs,mask)  ! qs is work array
<       call set_eta_alpha2     ! Set eta/h
< 
<       return
<       end
< c-----------------------------------------------------------------------
662,663d497
<       call dg_setup2(tmask(1,1,1,1,ifield-1))
< 
671d504
<          write(6,*) istep,time,bq(1,1,1,1,1),' bq'
675d507
< 
690a523,529
>          call bcneusc (ta,-1)
>          call add2    (h2,ta,n)
>          call bcdirsc (t(1,1,1,1,ifield-1))
>          call axhelm  (ta,t(1,1,1,1,ifield-1),h1,h2,imesh,isd)
>          call sub3    (tb,bq(1,1,1,1,ifield-1),ta,n)
>          call bcneusc (ta,1)
>          call add2    (tb,ta,n)
692,709d530
< c        call bcneusc (ta,-1)     !! Not Yet supported for DG
< c        call add2    (h2,ta,n)   !! Not Yet supported for DG
< 
<          call rzero             (tb,n)
<          call bcdirsc           (   t (1,1,1,1,ifield-1))
<          call conv_bdry_dg_weak (tb,t (1,1,1,1,ifield-1))
<          call hxdg_surfa        (tb,t (1,1,1,1,ifield-1),h1,h2)
<          call add2              (tb,bq(1,1,1,1,ifield-1),n)
< 
< c        call col3(ta,tb,binvdg,n)
< c        call outpost(ta,ta,ta,ta,ta,'   ')
< 
<          write(6,*) istep,time,h1(1),h2(1),'  h1 h2'
< c        write(6,*) istep,time,t(1,1,1,1,1),tb(1),' rq'
<          call hmholtz_dg(name4t,t(1,1,1,1,ifield-1),tb,h1,h2 
<      $                   ,tmask(1,1,1,1,ifield-1)
<      $                   ,tolht(ifield),nmxh)
<          write(6,*) istep,time,tb(1),t(1,1,1,1,1),' rq'
711,713c532,538
< c        call outpost(t,t,t,t,t,'   ')
< c        stop
<          return
---
> c        if (ifdg) then
> c           do i=1,n                        ! Quick Hack, 10/10/15, pff.
> c              s = h2(i)*bm1(i,1,1,1)
> c              ta(i)=tb(i)/s
> c              ta(i)=tmask(i,1,1,1,ifield-1)*tb(i)/s
> c           enddo
> c        elseif (iftmsh(ifield)) then
716c541
<            call hsolve  (name4t,t(1,1,1,1,ifield-1),tb,h1,h2 
---
>            call hsolve  (name4t,ta,tb,h1,h2 
722c547
<            call hsolve  (name4t,t(1,1,1,1,ifield-1),tb,h1,h2 
---
>            call hsolve  (name4t,ta,tb,h1,h2 
728a554,555
>          call add2    (t(1,1,1,1,ifield-1),ta,n)
> 
